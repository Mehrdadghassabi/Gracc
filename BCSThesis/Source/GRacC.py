# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rb0JRjsFtGO1TXf3sQKYz4LEI_WJqvNe
"""

!pip install numpy
!wget https://raw.githubusercontent.com/Mehrdadghassabi/Gracc/master/BCSThesis/Source/circuits/circuit1.txt

from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import minimum_spanning_tree
import numpy as np

# this function get the example circuit information
# from .txt file by parsing it
# 
# returns an array which contains
#   [nodesnumber ,
#    edgesnumber ,
#    array containing resistors of each edge ,
#    array containing batterys vlotage of each edge ,
#    array containing capacitors of each edge ,
#    array containing selves of each edge &
#    Kirchoff graph adjacency matrix]
def parsing_cicuit(circ):
     nodesnumber = 0
     edgesnumber = 0
     resistors = np.zeros((6), dtype=int)
     batterys = np.zeros((6), dtype=int)
     capacitors = np.zeros((6), dtype=int)
     selves = np.zeros((6), dtype=int)
     i = 0
     # i is the loop variable
     with open(circ) as f:
         for line in f:
            # for each line in the .txt file get the line number i
            omitnewlines = line.replace('\n', '')
            # remove newlines
            arrstr = omitnewlines.split(" ")
            arrint = [int(numeric_string) for numeric_string in arrstr]
            # in each lines there are some numbers
            # convert the line which is a string to array of numbers
            if i == 0 :
              # if its the first line it determines 
              # number of nodes & edges
              nodesnumber = arrint[0]
              edgesnumber = arrint[1]
              adjacencymatrix = np.zeros([nodesnumber,nodesnumber], dtype=int)
            else :
              # else it means that this line is an information about an edge
              # the origin and the destanation node
              # & information that an edge contains
              xmat = arrint[0]
              ymat = arrint[1]
              adjacencymatrix[xmat][ymat] = 1
              resistors[i-1] = arrint[2]
              batterys[i-1] = arrint[3]
              capacitors[i-1] = arrint[4]
              selves[i-1] = arrint[5]
            i = i + 1
     # return them as an array ! !!
     circ = [nodesnumber,edgesnumber,resistors,batterys,
             capacitors,selves,adjacencymatrix]

     return circ

# function to caculate minimum spaning tree of graph (thanks to scipy)
# takes kirchoff graph adjacencymatrix (kgam) as input
# returns minimum spanning tree adjacencymatrix of the mentioned graph
def mst(kgam):
    return minimum_spanning_tree(kgam).toarray().astype(int)

# this matrix takes kirchoff graph & minimum spaning tree
# and returns edges that eliminated 
# from kirchoff graph to build minimum spaning tree
#
# minimum spaning tree + eliminated edges = kirchoff graph 
def Eliminated_Edges(kg,mst):
    nodesnumber = len(kg)
    l = []
    for i in range(nodesnumber):
       for j in range(nodesnumber):
           if kg[i][j] == 1 and mst[i][j]== 0 :
              l.append([i,j])
    return np.array(l)

circuit1 = parsing_cicuit('circuit1.txt')
kgmst = mst(circuit1[6])
print(Eliminated_Edges(circuit1[6],kgmst))